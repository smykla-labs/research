#!/usr/bin/env python3
"""Unified CLI wrapper for claude-code skills.

Usage:
    claude-code-skills <skill-name> <command> [args...]
    claude-code-skills --list

Examples:
    claude-code-skills browser-controller tabs
    claude-code-skills ui-inspector list --app Finder
    claude-code-skills window-controller find --app "Google Chrome"
"""
from __future__ import annotations

import os
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path

# Directories to skip when discovering skills
SKIP_DIRS = {"_bin", "_shared", "__pycache__"}


@dataclass(frozen=True)
class SkillInfo:
    """Information about a discovered Python-based skill."""

    name: str
    path: Path
    module_name: str


def get_skills_dir() -> Path:
    """Get the skills directory (parent of _bin/)."""
    return Path(__file__).resolve().parent.parent


def get_workspace_root() -> Path:
    """Get the workspace root directory (parent of claude-code/)."""
    return get_skills_dir().parent.parent


def is_python_package(path: Path) -> bool:
    """Check if a directory is a valid Python package with CLI.

    A valid package must have:
    - __init__.py (makes it a package)
    - cli.py (CLI entry point)
    """
    return (path / "__init__.py").exists() and (path / "cli.py").exists()


def discover_skills() -> dict[str, SkillInfo]:
    """Discover available Python-based skills.

    Scans the skills directory for subdirectories containing valid Python
    packages with CLI entry points. Documentation-only skills and other
    non-Python directories are silently ignored.

    Returns:
        Dict mapping skill name to SkillInfo.
    """
    skills_dir = get_skills_dir()
    discovered: dict[str, SkillInfo] = {}

    for skill_path in skills_dir.iterdir():
        # Skip non-directories
        if not skill_path.is_dir():
            continue

        # Skip hidden and special directories
        if skill_path.name.startswith(".") or skill_path.name in SKIP_DIRS:
            continue

        # Look for a Python package inside the skill directory
        for subdir in skill_path.iterdir():
            if not subdir.is_dir():
                continue

            # Skip hidden and private directories
            if subdir.name.startswith((".", "_")):
                continue

            # Check if it's a valid Python package with cli.py
            if is_python_package(subdir):
                discovered[skill_path.name] = SkillInfo(
                    name=skill_path.name,
                    path=skill_path,
                    module_name=subdir.name,
                )
                break  # Found the module for this skill

    return discovered


def print_usage(skills: dict[str, SkillInfo]) -> None:
    """Print usage information."""
    print(__doc__)
    print("\nAvailable skills:")
    for skill_name in sorted(skills.keys()):
        print(f"  {skill_name}")
    print("\nUse 'claude-code-skills <skill-name> --help' for skill-specific help.")


def run_skill(skill: SkillInfo, args: list[str]) -> int:
    """Run a skill with the given arguments."""
    skills_dir = get_skills_dir()
    workspace_root = get_workspace_root()

    # Set PYTHONPATH to include the skill directory and shared module
    env = os.environ.copy()
    current_pythonpath = env.get("PYTHONPATH", "")
    paths = [str(skill.path), str(skills_dir)]
    if current_pythonpath:
        paths.append(current_pythonpath)
    env["PYTHONPATH"] = os.pathsep.join(paths)

    # Use uv run from workspace root to get dependencies
    # The PYTHONPATH ensures the skill module is found
    cmd = [
        "uv", "run",
        "--directory", str(workspace_root),
        "python", "-m", f"{skill.module_name}.cli", *args,
    ]

    try:
        result = subprocess.run(cmd, env=env)
        return result.returncode
    except KeyboardInterrupt:
        return 130  # Standard exit code for SIGINT


def main() -> int:
    """Main entry point."""
    skills = discover_skills()

    if len(sys.argv) < 2:
        print_usage(skills)
        return 1

    first_arg = sys.argv[1]

    # Handle --help and -h
    if first_arg in ("--help", "-h"):
        print_usage(skills)
        return 0

    # Handle --list
    if first_arg == "--list":
        for skill_name in sorted(skills.keys()):
            print(skill_name)
        return 0

    # Handle skill invocation
    skill_name = first_arg
    if skill_name not in skills:
        print(f"Error: Unknown skill '{skill_name}'", file=sys.stderr)
        print(f"\nAvailable skills: {', '.join(sorted(skills.keys()))}", file=sys.stderr)
        return 1

    # Pass remaining arguments to the skill
    skill_args = sys.argv[2:]
    return run_skill(skills[skill_name], skill_args)


if __name__ == "__main__":
    sys.exit(main())
